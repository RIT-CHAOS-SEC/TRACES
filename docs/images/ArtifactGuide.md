# TRACES: TEE-based Runtime Auditing for Commodity Embedded Systems

## Repository Description
This is the public repository for the prototype of TRACES: TEE-based Runtime Auditing for Commodity Embedded Systems. The [STM32CubeIDE](https://www.st.com/en/development-tools/stm32cubeide.html) is used for development, and TRACES is deployed on an [STM32 Nucleo-144 development board](https://www.st.com/en/evaluation-tools/nucleo-l552ze-q.html#overview) with STM32L552ZE MCU


## Paper Abstract
Control Flow Attestation (CFA) has become a vital technique to combat runtime attacks in low-cost embedded and IoT devices. CFA generates a trace (CFLog) containing the destination of all branching instructions executed. This allows a remote Verifier (Vrf) to inspect the execution control flow on a potentially compromised embedded device a Prover (Prv) – before trusting that a value/action was correctly produced/performed by Prv. While CFA can detect compromises that alter the control flow of Prv’s software, it cannot guarantee the eventual delivery of CFLog containing evidence of the compromise. For instance, a compromised Prv may refuse to send CFLog to prevent Vrf from identifying the exploit’s source and remediating the vulnerability. To address this challenge, we propose TRACES: TEE-based Runtime Auditing for Commodity Embedded Systems. In contrast with CFA, TRACES guarantees that Vrf always receives periodic runtime reports from Prv, even when Prv is compromised. This, in turn, enables secure runtime auditing, in addition to pure attestation. Furthermore, TRACES supports a “remediation” phase that Vrf can trigger upon compromise detection to patch the identified vulnerability and bring the compromised device to a healthy state. To the best of our knowledge, TRACES is the first system to provide this functionality on commodity devices (i.e., without requiring custom hardware modifications). To that end, TRACES leverages support from the ARM TrustZone-M Trusted Execution Environment (TEE). To demonstrate the practicality of this design, we implement and evaluate a fully functional prototype of TRACES atop the commodity ARM Cortex-M33 microcontroller unit.

## Exploit detection Example

### Description
The demo of TRACES includes an application that reads from an input buffer to determine which sensor program to execute (Ultrasonic, Temperature, or both), then parses this input in order to perform the proper actions. However, it contains an intentionally placed vulnerability -- a buffer overflow -- due to reading from the input buffer until a stop character is is encountered. Because of this, an attacker can overwrite the return address that was previously pushed onto the stack and cause arbitrary behavior.

In this application a function `process_command` calls a function `read_command`, and `read_command` contains the buffer overflow vulnerability. Since the return address of `process_command` is pushed onto the stack prior to calling `read_command`, its return address can be overwritten. The expected behavior after `process_command` is to return to `application` which then proceeds to call the proper sensor program. However, the buffer overflow caused by the attack input results in `process_command` returning to itself, essentially looping forever and preventing any sensor program from executing. 

### Results
The `vrf/cflog` directory contains the CFLogs generated by the two scenarios. As seen in `cflogs/attack/0.cflog`, a set of control flow events repeat infinitely despite there being no infinite loop. Whereas in `cflogs/benign/0.cflog`, the initial sequence eventually returns to perform the sensor readings.

## Requirements

1)  [STM32 Nucleo-144 development board](https://www.st.com/en/evaluation-tools/nucleo-l552ze-q.html#overview) with STM32L552ZE MCU
2) [STM32CubeIDE](https://www.st.com/en/development-tools/stm32cubeide.html) 1.13.1

# Import and setup STM32 Project

1) First, clone [this](https://github.com/RIT-CHAOS-SEC/TRACES) repository. 

2) Open the STM32CubeIDE and then import the files from `./prv/TRACES` into a project.

2) In the Project Explorer, click the drop-down arrow on `TRACES` to reveal `TRACES_NonSecure`. Right click `TRACES_NonSecure` and click "Properties". In the next window, click "C/C++ Build -> Settings -> MCU Post build outputs". Click the checkbox on the option "Generate list file". Then click "Apply and Close". 

3) Repeat step 2 for `TRACES_Secure`.

In the end you should have a project tree like :

![](images/projecttree.png)


# Step-by-Step Guide on Evaluating Attack and Benign Behavior

### 1. Select the Mode (Benign/Malicious)

Navigate to the `Traces/vrf/demo-vrf-source/` directory and run one of the following commands depending on the desired behavior mode:

```bash
# For benign behavior
./updatemem.sh -mode benign

# For malicious behavior
./updatemem.sh -mode malicious
```

### 2. Compile the Code

Open the STM32IDE and compile the code, building both projects.

### 3. Generate the Control Flow Graph and Update Memory Range

While still in the `Traces/vrf/demo-vrf-source/` directory, run the following command to obtain the control flow graph of the binary and update the memory range of the Non-Secure Code:

```bash
./readmem.sh
```

### 4. Recompile the Code

Open the STM32IDE and recompile the code, building both projects.


### 5. Run the application

In STM32CubeIDE, right-click TRACES_Secure. Then click "Run As" followed by "STM32 Cortex M C/C++ Application". Prv is now running and waiting for a request to run the application from Vrf



# Timing Measurements


### Expected results - Benign Scenario

When either `benign.s` is selected, the expected console output is below: 

![console output benign-access](images/demo-benign.png)

Verifier will determine that the reported CFLog abides by the CFG, Prv memory is in a valid state, and the MAC is authentic.
 
### Expected results - Attack Scenario

When `malicious.s` is selected, the expected console output is below:

![console output malicious-access](images/demo-attack.png)

During this execution, the MAC is determined to be valid. But, the contents of the CFLog denote a control-flow attack occurred due to the buffer overflow incurred by the malicious input. Because of TRACES triggers, the attack is identified in the next report received by Vrf.